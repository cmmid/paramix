% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregate.R
\name{alembic}
\alias{alembic}
\title{Create the Blending and Distilling Object}
\usage{
alembic(
  f_param,
  f_pop,
  model_partition,
  output_partition,
  pars_interp_opts = list(fun = stats::splinefun, method = "natural"),
  pop_interp_opts = list(fun = stats::approxfun, method = "constant", yleft = 0, yright =
    0)
)
}
\arguments{
\item{f_param}{a function, \code{f(x)} which transforms the feature (e.g. age),
to yield the parameter values. Alternatively, a \code{data.frame} where the first
column is the feature and the second is the parameter; see
\code{\link[=xy.coords]{xy.coords()}} for details. If the latter, combined with \code{pars_interp_opts},
and defaulting to spline interpolation.}

\item{f_pop}{like \code{f_param}, either a density function (though it does
not have to integrate to 1 like a pdf) or a \code{data.frame} of values. If the
latter, it is treated as a series of populations within intervals, and
then interpolated with \code{pop_interp_opts} to create a density function.}

\item{model_partition}{a numeric vector of cut points, which define the
partitioning that will be used in the model}

\item{output_partition}{the partition of the underlying feature}

\item{pars_interp_opts}{a list, minimally with an element \code{fun},
corresponding to an interpolation function. Defaults to \code{\link[=splinefun]{splinefun()}}
"natural" interpolation.}

\item{pop_interp_opts}{ibid, but for density. Defaults to \code{\link[=approxfun]{approxfun()}}
"constant" interpolation.}
}
\value{
a \code{data.table} with columns \code{model_part}, \code{out_part}, \code{weight} and
\code{relpop}. The first two columns identify which partitions, for both the model
and output, the other values are associated with; the combination of
\code{model_part} and \code{out_part} forms a unique identifier, but individually they
may appear multiple times. which maps fractions of the original model partitions
to the desired partitions, according to underlying relative outcome rates and
densities
}
\description{
Create the Blending and Distilling Object
}
\examples{
ifr_levin <- function(age_in_years) {
  (10^(-3.27 + 0.0524 * age_in_years))/100
}
age_limits <- c(seq(0, 69, by = 5), 70, 80, 100)
age_pyramid <- data.frame(
  from = 0:100, weight = ifelse(0:100 < 65, 1, .99^(0:100-64))
) # flat age distribution, then 1\% annual deaths
ifr_alembic <- alembic(ifr_levin, age_pyramid, age_limits, 0:100)

}
