---
title: "Introductory Usage"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introductory Usage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(scipen=100000)
```

```{r setup, echo = FALSE}
suppressPackageStartupMessages({
  library(YLLr)
  library(data.table)
  library(ggplot2)
  library(patchwork)
  library(wpp2022)
})
```

# Overview

The `YLLr` package provides convenient methods to (1) aggregate parameters from high-resolution curves depending on some feature for use in compartmental ODE models with lower-resolution in that feature and (2) disaggregate outcomes from model groups back to higher resolution breakdowns. Throughout the package, we use `blend` as the verb for aggregation and `distill` as the verb for disaggregation. We use age-dependent parameters as our primary example, but the package is generalizable to other features.

# Motivating Example

The SARS-COV-2 pathogen causes COVID-19, which has a distinctly age-specific mortality rate. In a meta-analysis, Levin et al (TODO citation) estimates the age-specific infection fatality ratio (IFR) for COVID-19 as:

```{r}
ifr_levin <- \(age_in_years) {
  scaled <- exp(-7.56 + 0.121 * age_in_years)
  scaled / (100 + scaled)
}
```

We will use this IFR function as a motivating example throughout this vignette.

# Example Comparison

Typically in ODE compartmental models have low-resolution stratification combining several ages, for computational reasons, because of low-resolution date on other interactions like contact patterns, and to match intervention targets (e.g. children versus working age adults versus retirees).

When mixing several ages into a single compartment, what is the properly blended version of parameters like IFR? Generally, $E[f(x)] \ne f(E[x])$, so simply using the IFR at the mean age for the compartment is not guaranteed correct. The average IFR over the age range is more correct, but that assumes uniform distribution of ages, which is not generally true. The proper average of IFR needs to be weighted by the age distribution, or:

$$
\textrm{IFR}\Big\rvert_a^b = \frac{\int_a^b \textrm{IFR}(\textrm{age})\rho(\textrm{age})d\textrm{age}}{\int_a^b \rho(\textrm{age})d\textrm{age}}
$$

Let's compare the various calculations of IFR for two different population age distributions: the United Kingdom and Afghanistan. Recall, we have considered using:

 - the average age in the function, i.e. $\textrm{IFR}\Big\rvert_a^b = \textrm{IFR}(\frac{a+b}{2})$
 - the function average, assuming uniform age distribution, i.e. $\textrm{IFR}\Big\rvert_a^b = \int_a^b \textrm{IFR}(\textrm{age})d\textrm{age}$
 - the weighted function average (as above)

Let's imagine a compartmental model with age groups [0,5), [5,20), [20,65), and [65,101), corresponding roughly to pre-school age children, school age individuals, prime working age adults, and post-working age adults. First, we need to get the relevant values:

```{r,create_pops}
# our model age groups
model_agelimits <- c(0, 5, 20, 65, 101)
# get select data from World Population Prospects estimates
data('popF'); data('popM')
setDT(popF); setDT(popM)
density_dt <- rbind(
  popF[name %like% "United Kingdom|Afghanistan", .(name, age, `2020`)],
  popM[name %like% "United Kingdom|Afghanistan", .(name, age, `2020`)]
)[, .(
  weight = sum(`2020`)
), by = .(name, from = as.integer(gsub("^(\\d+).*","\\1", age)))]
```

Now let's make a plot of the IFR values for the different age groups, under different approaches to computing them. We'll use the package function `parameter_summary`, which provides a convenient breakdown of the parameter values:

```{r, cache=T,fig.width=5,fig.height=3}
plot_dt <- rbind(
  parameter_summary(
    f_param = ifr_levin, densities = density_dt[name == "United Kingdom"],
    model_agelimits
  )[, variable := fifelse(variable != "wm_f", variable, "uk_wm_f")],
  parameter_summary(
    f_param = ifr_levin, densities = density_dt[name == "Afghanistan"],
    model_agelimits
  )[variable == "wm_f", variable := "af_wm_f"]
)

pop_p <- ggplot(density_dt) + aes(from, weight) + geom_bar(stat = "identity") +
  facet_grid(cols = vars(name)) +
  scale_x_continuous("Age", expand = expansion()) +
  scale_y_continuous("Population [1K]")
  theme_minimal()
  
ifr_p <- ggplot(plot_dt) + aes(x = x, color = variable, y = value) + 
  geom_line(data = \(dt) dt[variable == "f_val"], lwd = 0.8, lty = "dotted") +
  geom_step(data = \(dt) dt[variable != "f_val"]) +
  scale_color_discrete(
    "Method",
    breaks = plot_dt[, value[.N], by = variable][order(-V1), variable],
    labels = c("f(age)", "E[f(age)]", "f(E[age])", "UK-weighted E[f(age)]", "AF-weighted E[f(age)]")
  ) +
  scale_y_continuous("Infection Fatality Ratio\n(IFR)", expand = expansion()) +
  scale_x_continuous("Age [years]", breaks = 10 * (0:10), expand = expansion()) +
  theme_minimal() +
  theme(
    legend.position = "inside", legend.position.inside = c(0.1, 0.9),
    legend.justification.inside = c(0, 1)
  )

pop_p / ifr_p
```

Clearly, these different approaches would result in different mortality outcomes for otherwise identical infection patterns. 

# Typical Application

In the previous section, we used a convenience method the package provides for plotting. More typically, you will want to use the three main functions in the package:

 - `blend` to create the correctly weighted mixture parameters
 - `alembic` to create a properly weighted mapping from one resolution to another
 - `distill` to apply an `alembic` mapping to model outputs

Revisiting our previous example, the properly age-weighted IFRs look like:

```{r params}
params <- rbind(
  uk = blend(ifr_levin, densities = density_dt[name == "United Kingdom"], model_partition = model_agelimits),
  af = blend(ifr_levin, densities = density_dt[name == "Afghanistan"], model_partition = model_agelimits)
)
signif(params, digits = 2)
```

These parameters are now weighted for use in a model assuming those age categories and populations. Great! However: once you run that model, you might want to disaggregate an outcome, such as for example converting deaths into years of life lost.

In this example, since the IFR increases with age, deaths occurring in a wide age group are more likely to have occurred at the older end of the age group. Let's compare a few approaches for imputing the distribution of deaths; we could assume the deaths occur ...

 - all at the middle age in the group
 - uniformly within group,
 - proportionally to age distribution within the group,
 - proportionally to age *and* relative mortality rates.

For the last option, we can use Bayes rule to think about the correct proportionality:

$$
\textrm{P}\left(\textrm{Age} \vert \textrm{Death}\right) = \frac{\textrm{P}\left(\textrm{Death} \vert \textrm{Age}\right)\textrm{P}\left(\textrm{Age}\right)}{\textrm{P}\left(\textrm{Death}\right)}
$$

We know that $\textrm{P}\left(\textrm{Age}\right)$ is the relative fraction of an age within any group, and $\frac{\textrm{P}\left(\textrm{Death} \vert \textrm{Age}\right)}{\textrm{P}\left(\textrm{Death}\right)}$ is the relative rate of that outcome for that age within that same group. We can thus use those terms to calculate $\textrm{P}\left(\textrm{Age} \vert \textrm{Death}\right)$ on a per-group basis, and allocate the death outcomes accordingly.

For demonstration purposes, let's assume 1M *infections* that happen proportionally across the model population groups[^1]. How would these translate into deaths in finer age groups, based on these different imputation assumptions? Our differently parametrised models would have converted these infections to deaths as follows:

[^1]: More typically, the distribution of infections would reflect other factors such as varying contact patterns. How the infections are actually distributed would determine the particular quantitative differences for our demonstration, but not the qualitative point.

```{r}
model_density_dt <- density_dt[,.(
  model_from = model_agelimits[findInterval(from, model_agelimits)],
  weight
), by = name][, .(weight = sum(weight)), by = .(name, model_from)][,
  weight := weight/sum(weight), by = name
]
model_deaths_dt <- model_density_dt[,
  .(model_from, deaths = weight*1e6*params[ifelse(.BY == "United Kingdom", "uk", "af"),]),
  by = name
]
model_deaths_dt
```

For these approaches, we get the following distribution of deaths by age category:

```{r alembicsetup}
# setup the model to outcome mapping using `alembic`s
mapping_dt <- c("United Kingdom", "Afghanistan") |>
  lapply(\(nm) alembic(
    ifr_levin, densities = density_dt[name == nm],
    model_partition = model_agelimits,
    new_partition = density_dt[, seq_len(max(from) + 2L) - 1L]
  )[, name := nm]
) |> rbindlist()
# for reference, get a uniform density of the reference density
uniform_density_dt <- density_dt[, {
  mapply(seq, from = from, to = c(from[-1], tail(model_agelimits, 1)), MoreArgs = list(by = 1)) |>
  mapply(\(ages, total) data.table(age = ages, weight = total / length(ages)),
    ages = _, total = weight,
    SIMPLIFY = FALSE
  ) |> rbindlist()
}, by = name]

methods_dt <- rbind(
# approach 1: all deaths at mean age
model_deaths_dt[, .(
  name,
  age = head(model_agelimits, -1) + diff(model_agelimits)/2,
  deaths,
  method = "mean_age"
)],

# approach 2: deaths spread uniformly within group
model_deaths_dt[, {
  all_ages <- mapply(seq, from = model_from, to = model_agelimits[-1] - 1L, MoreArgs = list(by = 1))
  mapply(
    \(ages, total) data.table(age = ages, deaths = total / length(ages)),
    ages = all_ages, total = deaths,
    SIMPLIFY = FALSE
  ) |> rbindlist()
}, by = name][, method := "uniform_model"],

# approach 3: proportionally to age distribution within the group
uniform_density_dt[
  mapping_dt, on = .(name, age = new_from)
][model_deaths_dt, on = .(name, model_from)][, .(
  age, deaths = weight/sum(weight)
), by=.(name, model_from)][, .(name, age, deaths, method = "uniform_age")],

# approach 4: proportionally to age *and* relative mortality rates
model_deaths_dt[
  mapping_dt, on = .(name, model_from), .(
  name, age = new_from, deaths = deaths * model_fraction
)][, method := "alembic_weighted"]
)

ggplot(methods_dt) + aes(x = age, y = deaths, color = method) +
  facet_grid(. ~ name) +
  geom_point() +
  theme_minimal() +
  scale_y_log10()
```

The distribution of deaths produced by method 4 reflects that within any 5-year age band, deaths are more likely to occur at older ages, and that the overall distribution of deaths reflects both age distribution (which varies between the UK and Afghanistan) and the shape of the relative mortality rates (which is consistent across both populations).

When we combine these different deaths-by-age with life expectancy estimates, we see these differences in estimated years-life-lost. Without the necessary adjustments for both age structure and mortality shape, we typically overestimate YLLs.

```{r, cache=T,fig.width=5,fig.height=3}
data("mxB1")
mxB1 <- data.table(mxB1)
## calculating life expectancy at all ages from mx 
for(country in c('United Kingdom','Afghanistan')){
  lt <- mxB1[name == country,][, c('name','age','2020')]
  setnames(lt,'2020','mx')
  lt[, ax := 0.5][age==0, ax := 0.2][, qx := (mx)/(1 + mx*(1-ax))]
  lt[age==max(lt$age), qx := 1][age==0, lx:=1000]
  for(i in 2:nrow(lt)){
    lt[i, lx := (1-lt[i-1,qx])*lt[i-1,lx]]
  }
  for(i in 1:(nrow(lt)-1)){
    lt[i, Lx := lt[i+1,lx] + lt[i,ax]*(lt[i,lx]-lt[i+1,lx])]
  }
  lt[age==max(lt$age), Lx := lx]
  lt <- lt[order(-age),]
  lt[, ex := cumsum(Lx)/1000]
  lt <- lt[order(age)]
  death_distr <- death_distr[lt, on='age', ex := ex]
  setnames(death_distr,'ex',country)
}
## ylls = sum(deaths at age x * life expectancy from age x) 
ylls <- death_distr[, c('age','method1','method2','method3uk','method3afg','method4uk','method4afg','United Kingdom','Afghanistan')]
ylls[, uk_yll_1:=method1*`United Kingdom`][, uk_yll_2:=method2*`United Kingdom`][, uk_yll_3:=method3uk*`United Kingdom`][, uk_yll_4:=method4uk*`United Kingdom`]
ylls[, afg_yll_1:=method1*`Afghanistan`][, afg_yll_2:=method2*`Afghanistan`][, afg_yll_3:=method3afg*`Afghanistan`][, afg_yll_4:=method4afg*`Afghanistan`]
yll_cols <- which(grepl('yll',colnames(ylls)))
ylls_sum <- data.table(country = rep(c('United Kingdom','Afghanistan'),each=4),
                       method = rep(1:4,2),
                       ylls = colSums(ylls[, ..yll_cols]))
ggplot(ylls_sum) + 
  geom_bar(aes(x=country, y=ylls/1000000, fill=as.factor(method)),
           position='dodge',stat='identity') + 
  theme_bw() + labs(fill='Method') + scale_fill_brewer(palette='Set1') + 
  ylab('YLLs (millions)') + xlab('Country')
```

With the `YLLr` package, we can efficiently account for age structure and mortality shape:

```{r, cache=T,fig.width=5,fig.height=3}
vals <- c(100, 1000, 100000, 1000000) # number of deaths in each model age group
disagg_values <- rbind(
  cbind(disaggregate_value(vals,ifr_levin,model_agegrps, uk_pop_dt), 
        country='United Kingdom'),
  cbind(disaggregate_value(vals,ifr_levin,model_agegrps,afg_pop_dt),
        country='Afghanistan'))
ggplot(disagg_values) + 
  geom_bar(aes(x=age,y=disagg_value/1000,fill=country),
               lwd=0.8, position='dodge',stat='identity') + 
  facet_wrap(country~., scales='free', nrow=3) +
  xlab('Age') + ylab('Deaths (thousands)') + 
  theme_minimal() + scale_fill_brewer(palette='Set2') +
  theme(legend.position='none')
```

In summary, properly accounting for age-specific effects across multiple different age bands requires careful bookkeeping and can result in substantively different answers. Using `YLLr` automates the bookkeeping step, so that your analyses can more easily account for potentially important differences.
