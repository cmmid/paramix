---
title: "Introductory Usage"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(scipen=100000)
```

```{r setup, echo = FALSE}
suppressPackageStartupMessages({
  library(paramix)
  library(data.table)
  library(ggplot2)
  library(patchwork)
  library(wpp2022)
})
```

The `paramix` package provides translation of parameters for use in compartmental models. Imagine you have compartment stratifications discretising some feature -- for example, converting continuous age into age category compartments -- but processes of interest may depend on that feature. How do you get the right aggregate parameters for the compartment rates from process function? And once you get outcomes for your stratified compartments, is there anyway to impute their higher-resolution distribution?

With `paramix`, the `blend()` function will translate from continuous parameter relationships to the correctly averaged values. In turn, the `distill()` function will impute how the gross group outcome should be distributed to finer resolution levels. These functions use mappings between low and high resolution that are created with the `alembic()` function.

In this vignette, we demonstrate applying these functions from an initial functional relationship through a final analytic process. To highlight the use of the package, we prepend `paramix::` to the package functions.

## Motivating Example

The SARS-COV-2 pathogen causes COVID-19, which has a distinctly age-specific mortality rate. In a meta-analysis, Levin et al[^1] estimates the age-specific infection-fatality ratio (IFR) for COVID-19 as:

[^1]: [Assessing the age specificity of infection fatality rates for COVID-19: systematic review, meta-analysis, and public policy implications](https://doi.org/10.1007/s10654-020-00698-1)

```{r ifrfdef}
ifr_levin <- function(age_in_years) {
  scaled <- exp(-7.56 + 0.121 * age_in_years)
  scaled / (100 + scaled)
}
```

```{r, echo=FALSE,out.width = "100%",dpi = 600,fig.width = 8,fig.height = 3}
ggplot(data=data.frame(x=0:100,y=ifr_levin(0:100)),aes(x,y)) +
         geom_line() + theme_minimal() + 
         xlab('Age') + ylab('Infection-fatality ratio')
```

One typical measurement of public health outcomes is "years life lost" (YLLs). Based on age-specific mortality data, we can estimate how many years individuals at various ages can expect to live. People who die of a modeled illness lose a corresponding number of years of life, depending on their age at death. 

In this vignette, we will turn a continuous IFR relationship into compartmental aggregate IFR and deaths for broader age groups, back to age-specific deaths, and use these to estimate YLLs.

## Parametrizing a Compartmental Model

Typically, ODE compartmental models have low-resolution stratification combining several ages for computational reasons, because of low-resolution data on other interactions like contact patterns, and to match intervention targets (e.g. children versus working age adults versus retirees).

When mixing several ages into a single compartment, what is the properly aggregated value of parameters like the IFR? Generally, $E\left[f\left(x\right)\right] \ne f\left(E\left[x\right]\right)$, so simply using the IFR at the mean age for the compartment is not guaranteed to be correct. The average IFR over the age range is more reasonable, but that assumes a uniform distribution of individuals by age, which is not generally true. The proper average of IFR needs to be weighted by the age distribution, or:

$$
\textrm{IFR}\Big\rvert_a^b = \frac{\int_a^b \textrm{IFR}(\textrm{age})\rho(\textrm{age})d\textrm{age}}{\int_a^b \rho(\textrm{age})d\textrm{age}}
$$

We can compare the various calculations of the IFR for two different population age distributions: Afghanistan and the United Kingdom. Recall, we have considered using:

 - the average age in the function, i.e. $\textrm{IFR}(\frac{a+b}{2})$
 - the function average, assuming uniform age distribution, i.e. $\int_a^b \textrm{IFR}(\textrm{age}) d\textrm{age}$
 - the weighted function average (as above)

Let's imagine a compartmental model with age groups [0,5), [5,20), [20,65), and [65,101), corresponding roughly to pre-school age children, school age individuals, prime working age adults, and post-working age adults. First, we need to get the relevant values:

```{r, create_pops, cache = TRUE}
# our model age group cut points
model_agelimits <- c(0, 5, 20, 65, 101)
# get select data from World Population Prospects estimates
data("popAge1dt")
density_dt <- popAge1dt[
  name %like% "Afghanistan|United Kingdom" & year == 2021,
  .(name, from = age, weight = pop)
]
rm(popAge1dt)
```

We can calculate the IFR values for each model age group, under different approaches to computing them. We'll use the package function `parameter_summary()`, which provides a convenient comparison of the parameter values for these approaches to summarisation:

```{r ifrplotsetup, cache=TRUE}
plot_dt <- density_dt[, {
  paramix::parameter_summary(
    f_param = ifr_levin, densities = .SD, model_agelimits
  )
}, by = name][
  name == "Afghanistan" | method == "wm_f"
][,
  method := fifelse(method == "wm_f", fifelse(name == "Afghanistan", "af_wm_f", "uk_wm_f"), method)
][, .SD, .SDcols = -c("name")]
# parameter_summary yields method in (f_val, f_mean, mean_f, wm_f)
# with the exception of wm_f, these are independent of density, so we can drop
# duplicates
```

And plotting these different blends:

```{r, ifrfig, echo = FALSE, cache = TRUE, out.width = "100%", dpi = 600, fig.width = 8, fig.height = 5}
pop_p <- ggplot(density_dt) + aes(from, weight) + geom_bar(stat = "identity") +
  facet_grid(cols = vars(name)) +
  scale_x_continuous("Age", expand = expansion()) +
  scale_y_continuous("Population (thousands)") +
  theme_minimal() + theme(panel.spacing.x = unit(1.5, "line"))
  
ifr_p <- ggplot(plot_dt) + aes(x = x, color = method, y = value) + 
  geom_line(data = \(dt) dt[method == "f_val"], lwd = 0.8, lty = "dotted") +
  geom_step(data = \(dt) dt[method != "f_val"]) +
  scale_color_discrete(
    NULL,
    breaks = plot_dt[, value[.N], by = method][order(-V1), method],
    labels = c(
      f_val = "f(age)", mean_f = "E[f(age)]", f_mean = "f(E[age])",
      af_wm_f = "AF-weighted E[f(age)]", uk_wm_f = "UK-weighted E[f(age)]"
    )
  ) +
  scale_y_continuous("Infection-fatality ratio", expand = expansion()) +
  scale_x_continuous("Age", breaks = 10 * (0:10), expand = expansion()) +
  theme_minimal() +
  theme(
    legend.position = "inside", legend.position.inside = c(0.1, 1),
    legend.justification.inside = c(0, 1)
  )

(pop_p / ifr_p) & theme(text = element_text(size = 10))
```

Clearly, these different approaches result in different mortality outcomes for otherwise identical infection patterns. 

## Typical Application

In the previous section, we used a convenience method the package provides for plotting. More typically, you will want to use the three main functions in the package:

 - `alembic()` to create a properly weighted mapping from one resolution to another
 - `blend()` to create the correctly weighted mixture parameters
 - `distill()` to apply an `alembic` mapping to model outputs

Revisiting our previous example, the properly age-weighted IFRs look like:

```{r params}
# setup the model to outcome mapping using `alembic`s
mapping_dt <- density_dt[, 
  paramix::alembic(
    ifr_levin, densities = .SD,
    model_partition = model_agelimits,
    new_partition = seq(min(from), max(from) + 1L)
  ),
  by = name
]

params <- mapping_dt[, paramix::blend(.SD), by=name]
```

```{r paramstbl, echo = FALSE}
params |> dcast(model_from ~ name)
```

These parameters are now weighted correctly for use in a model with those age groups and underlying populations. Once you run that model, you might want to disaggregate an outcome, such as for example converting deaths into years of life lost.

In this example, since the IFR increases with age, deaths occurring in a wide age group are more likely to have occurred at the older end of the age group. We can compare a few approaches for calculating the distribution of deaths, in order of increasing accuracy: we could assume that deaths occur

 - all at the middle age in the age group,
 - uniformly within the age group,
 - proportional to age distribution within the group,
 - proportional to age *and* relative mortality rates.

For the last option, we can use Bayes' theorem to calculate about the correct proportionality:

$$
\textrm{P}\left(\textrm{Age} \vert \textrm{Death}\right) = \frac{\textrm{P}\left(\textrm{Death} \vert \textrm{Age}\right)\textrm{P}\left(\textrm{Age}\right)}{\textrm{P}\left(\textrm{Death}\right)}
$$

We know that $\textrm{P}\left(\textrm{Age}\right)$ is the relative fraction of an age within any age group, and $\frac{\textrm{P}\left(\textrm{Death} \vert \textrm{Age}\right)}{\textrm{P}\left(\textrm{Death}\right)}$ is the relative mortality rate for that age within that same age group. We can therefore use those terms to calculate $\textrm{P}\left(\textrm{Age} \vert \textrm{Death}\right)$, and allocate the mortality outcomes accordingly.

For demonstration purposes, let's assume that one million infections occur proportionally across the model population groups[^2]. Using our properly-weighted IFR values for each age group from above, these infections result in deaths as follows:

[^2]: More typically, the distribution of infections would reflect other factors such as varying contact patterns. How the infections are actually distributed would determine the particular quantitative differences for our demonstration, but not the qualitative point.

```{r modeldeaths}
model_density_dt <- density_dt[,.(
  model_from = model_agelimits[findInterval(from, model_agelimits)],
  weight
), by = name][, .(weight = sum(weight)), by = .(name, model_from)][,
  weight := weight/sum(weight), by = name
]
model_deaths_dt <- model_density_dt[
  params, on = .(name, model_from)
][,
  .(name, model_from, deaths = weight * 1e6 * value)
]
```

```{r deathtbl, echo = FALSE}
tbl2 <- model_deaths_dt |> dcast.data.table(model_from ~ name, value.var = "deaths") |> as.data.frame()
tbl2$model_from <- NULL
row.names(tbl2) <- paste(head(model_agelimits, -1), tail(model_agelimits, -1) - 1L, sep = " - ")
knitr::kable(tbl2)
```

How would these translate into age-specific deaths, based on these different calculation methods? For convenience, `paramix` can compute all approaches mentioned above for comparison:

```{r alembicsetup}
distill_methods_dt <- model_deaths_dt[,
  paramix::distill_summary(
    .SD[,.(model_from, value = deaths)],
    density_dt[name == .BY],
    mapping_dt[name == .BY]
  ),
  by = name
]
```

You can see the calculations by entering `paramix::distill_summary` (no parentheses) as an R prompt. Plotted, the results for the four different methods of calculation look like:

```{r alembicplot, echo = FALSE, cache = TRUE, out.width = "100%", fig.width = 8, fig.height = 5, , dpi = 600}
ggplot(distill_methods_dt) + aes(x = partition, y = value, color = method) +
  facet_grid(. ~ name) +
  geom_point() +
  theme_minimal() + theme(
    legend.position = "inside", legend.position.inside = c(1, 0),
    legend.justification.inside = c(1, 0), text = element_text(size = 10)
  ) +
  scale_y_log10("Deaths (log 10 scale)") +
  scale_x_continuous("Age") +
  scale_color_discrete(
    "Method",
    breaks = c("mean_partition", "uniform_model", "alembic_weighted", "proportional_density"),
    labels = \(b) c(
      mean_partition = "Deaths at mean age",
      uniform_model = "Deaths uniform across age group",
      alembic_weighted = "paramix approach",
      proportional_density = "Deaths proportional to age distribution"
    )[as.character(b)]
  )
```
When we combine these different deaths-by-age with life expectancy estimates, we see these differences in estimated years of life lost. Without the necessary adjustments for both age structure and mortality shape, we typically overestimate YLLs.

```{r, figlex, echo = FALSE, cache = TRUE, out.width = "100%", fig.width = 8, fig.height = 3, dpi = 600}
data("mxB1")
life_expectancy_dt <- setDT(mxB1)[
  name %in% c('United Kingdom','Afghanistan'),
  .(name, age, mx = `2021`)
][, ax := fifelse(age == 0, 0.2, 0.5) ][,
  qx := fifelse(age == max(age), 1, mx / (1 + mx*(1-ax)))
]
life_expectancy_dt[age == 0, lx := 1000]
life_expectancy_dt[, lx := {
  tmp <- lx
  for (i in 2:.N) {
    tmp[i] <- (1-qx[i-1])*tmp[i-1]
  }
  tmp
}, by = name]
life_expectancy_dt[,
  Lx := c(tail(lx, -1) + head(ax, -1)*(head(lx, -1) - tail(lx, -1)), tail(lx, 1)),
  by = name
]
life_expectancy_dt[, ex := rev(cumsum(rev(Lx)/1000)), by = name]

# because of the selected breakpoints, there are some half-ages, so will
# manually add those as mean of age & age + 1 ex (ignoring other features)
life_expectancy_dt <- rbind(
  life_expectancy_dt,
  life_expectancy_dt[age %in% c(2, 12, 42, 82)][, age := age + 0.5][,
    ex := (ex + life_expectancy_dt[age %in% (c(2, 12, 42, 82) + 1L)]$ex)/2
  ]
)

yll_dt <- distill_methods_dt[
  life_expectancy_dt, on = .(name, partition = age)
][, .(YLL = sum(value*ex)), by = .(name, method)]

yllord <- yll_dt[name == "Afghanistan", method[order(YLL)]]

yll_dt[, method := factor(method, levels = yllord, ordered = TRUE)]
yll_dt$method <- factor(yll_dt$method, levels=c('alembic_weighted','mean_partition','uniform_model','proportional_density'))

ggplot(yll_dt) + aes(x = name, y = YLL/1e4, fill = method) +
  geom_bar(position = 'dodge', stat = 'identity') + 
  theme_minimal() + 
  theme(
    legend.position = "inside", legend.position.inside = c(0.1, 0.9),
    legend.justification.inside = c(0, 1), text = element_text(size = 8)
  ) +
  scale_fill_brewer("Method", palette = 'Set1',
                      labels = \(b) c(
                        mean_partition = "Deaths at mean age",
                        uniform_model = "Deaths uniform across age group",
                        alembic_weighted = "paramix approach",
                        proportional_density = "Deaths proportional to age distribution"
                      )[as.character(b)]) + 
  ylab('YLLs per one million infections\n(10,000 person-years)') + xlab('Country')
```

# Summary

Properly blending and distilling parameter values can make a relatively large difference when estimating outcomes that are non-linear, for example years-life-lost. This package can make doing that correctly relatively easy.
