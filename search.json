[{"path":"https://cmmid.github.io/paramix/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 paramix authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://cmmid.github.io/paramix/articles/intro.html","id":"motivating-example","dir":"Articles","previous_headings":"","what":"Motivating Example","title":"Introductory Usage: `paramix`","text":"SARS-COV-2 pathogen causes COVID-19, distinctly age-specific mortality. meta-analysis, Levin et al1 estimated age-specific infection-fatality ratio (IFR) COVID-19 :  evaluate threat infectious disease, researchers often calculate expected “years life lost” (YLLs). Based age-specific mortality data, can estimate many years individuals various ages can expect live. People die modelled illness lose corresponding number years life, depending age death. vignette, turn continuous IFR relationship compartmental aggregate IFR deaths broader age groups, back age-specific deaths, use estimate YLLs.","code":"ifr_levin <- function(age_in_years) {   (10^(-3.27 + 0.0524 * age_in_years))/100 }"},{"path":"https://cmmid.github.io/paramix/articles/intro.html","id":"parametrizing-a-compartmental-model","dir":"Articles","previous_headings":"","what":"Parametrizing a Compartmental Model","title":"Introductory Usage: `paramix`","text":"Typically, ODE compartmental models low-resolution stratification combining several ages mix computational reasons, data-availability interactions like contact patterns, match intervention targets (e.g. vaccinating children versus working age adults versus retirees). mixing several ages single compartment, properly aggregated value parameters like IFR? Generally, E[f(x)]≠f(E[x])E\\left[f\\left(x\\right)\\right] \\ne f\\left(E\\left[x\\right]\\right), using IFR mean age compartment guaranteed correct. average IFR age range reasonable, assumes uniform distribution individuals age, generally true. proper average IFR needs weighted age distribution, : IFR|ab=∫abIFR(age)ρ(age)dage∫abρ(age)dage \\textrm{IFR}\\Big\\rvert_a^b = \\frac{\\int_a^b \\textrm{IFR}(\\textrm{age})\\rho(\\textrm{age})d\\textrm{age}}{\\int_a^b \\rho(\\textrm{age})d\\textrm{age}} can compare various calculations IFR two different population age distributions: Afghanistan United Kingdom. Recall, considered using: average age function, .e. IFR(+b2)\\textrm{IFR}(\\frac{+b}{2}) function average, assuming uniform age distribution, .e. ∫abIFR(age)dage\\int_a^b \\textrm{IFR}(\\textrm{age}) d\\textrm{age} weighted function average () Let’s imagine compartmental model age groups [0,5), [5,20), [20,65), [65,101], corresponding roughly pre-school age children, school age individuals, prime working age adults, post-working age adults. First, need get relevant values: can calculate IFR values model age group, different approaches computing . ’ll use package function parameter_summary(), provides convenient comparison parameter values approaches summarisation: plotting different blends:  Clearly, different approaches result different mortality outcomes otherwise identical infection patterns.","code":"# our model age group cut points model_agelimits <- c(0, 5, 20, 65, 101) # get select data from World Population Prospects estimates data(\"popF\", package = \"wpp2019\") data(\"popM\", package = \"wpp2019\")  pop_dt <- as.data.table(popF)[,   .(name, age, popF = `2020`) ][   as.data.table(popM), on = c(\"name\", \"age\"),   .(name, age, popF, popM = `2020`) ][, age := as.integer(gsub(\"^(\\\\d+)[-+].*$\",\"\\\\1\", age)) ][   name %like% \"Afghanistan|United Kingdom\" ]  density_dt <- pop_dt[,   .(     from = c(age, max(age)+1),     weight = c(popF + popM, 0)   ), by = name ]  rm(popF) rm(popM) plot_dt <- density_dt[, { # compute parameters for each country of interest   paramix::parameter_summary(     f_param = ifr_levin, f_pop = .SD, model_agelimits   ) }, by = name]"},{"path":"https://cmmid.github.io/paramix/articles/intro.html","id":"typical-application","dir":"Articles","previous_headings":"","what":"Typical Application","title":"Introductory Usage: `paramix`","text":"previous section, used convenience method package provides plotting. typically, want use three main functions package: alembic() make weighted mapping one resolution another blend() aggregate associated weighted mixture parameters distill() impute finer scale outcomes model outputs Revisiting previous example, properly age-weighted IFRs look like: parameters now weighted correctly use model age groups underlying populations. run model, might want disaggregate outcome, example converting deaths years life lost. example, since IFR increases age, deaths occurring wide age group likely occurred older end age group. can compare approaches calculating distribution deaths: assume deaths occur middle age age group, uniformly within age group, proportional age distribution within group, proportional age relative mortality rates. last option, can use Bayes’ theorem calculate correct proportionality: P(Age|Death)=P(Death|Age)P(Age)P(Death) \\textrm{P}\\left(\\textrm{Age} \\vert \\textrm{Death}\\right) = \\frac{\\textrm{P}\\left(\\textrm{Death} \\vert \\textrm{Age}\\right)\\textrm{P}\\left(\\textrm{Age}\\right)}{\\textrm{P}\\left(\\textrm{Death}\\right)} know P(Age)\\textrm{P}\\left(\\textrm{Age}\\right) relative fraction age within age group, P(Death|Age)P(Death)\\frac{\\textrm{P}\\left(\\textrm{Death} \\vert \\textrm{Age}\\right)}{\\textrm{P}\\left(\\textrm{Death}\\right)} relative mortality rate age within age group. can therefore use terms calculate P(Age|Death)\\textrm{P}\\left(\\textrm{Age} \\vert \\textrm{Death}\\right), allocate mortality outcomes accordingly. demonstration purposes, let’s assume one million infections occur proportionally across model population groups2. Using properly-weighted IFR values age group , infections result deaths follows: translate age-specific deaths, based different calculation methods? convenience, paramix can compute approaches mentioned comparison: can see calculations entering paramix::distill_summary (parentheses) R prompt. Plotted, results four different methods calculation look like: combine different deaths--age life expectancy estimates, see differences estimated years life lost. Without necessary adjustments age structure mortality shape, typically overestimate YLLs.","code":"# setup the model to outcome mapping using `alembic`s mapping_dt <- density_dt[,   paramix::alembic(     f_param = ifr_levin, f_pop = .SD,     model_partition = model_agelimits,     output_partition = { res <- seq(min(from), max(from), by = 5L); res[length(res)] <- tail(model_agelimits, 1); res }    ),   by = name ]  params <- mapping_dt[, paramix::blend(.SD), by = name] model_density_dt <- density_dt[, .(   model_partition = model_agelimits[findInterval(from, model_agelimits)],   weight ), by = name][, .(weight = sum(weight)), by = .(name, model_partition)][,   weight := weight / sum(weight), by = name ] model_deaths_dt <- model_density_dt[   params, on = .(name, model_partition) ][,   .(name, model_partition, deaths = weight * 1e6 * value) ] distill_methods_dt <- model_deaths_dt[,   paramix::distill_summary(     mapping_dt[name == .BY],     .SD[, .(model_partition, value = deaths)]   ),   by = name ] #> Warning: Removed 2 rows containing missing values or values outside the scale range #> (`geom_bar()`)."},{"path":"https://cmmid.github.io/paramix/articles/intro.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Introductory Usage: `paramix`","text":"Properly blending distilling parameter values can make relatively large difference estimating outcomes non-linear, example years-life-lost. package can make correctly relatively easy.","code":""},{"path":"https://cmmid.github.io/paramix/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Carl Pearson. Author, maintainer. Simon Proctor. Author. Lucy Goodfellow. Author.","code":""},{"path":"https://cmmid.github.io/paramix/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Pearson C, Proctor S, Goodfellow L (2024). paramix: Aggregate Disaggregate Continuous Parameters Compartmental Models. R package version 0.0.1, https://cmmid.github.io/paramix/.","code":"@Manual{,   title = {paramix: Aggregate and Disaggregate Continuous Parameters for Compartmental Models},   author = {Carl Pearson and Simon Proctor and Lucy Goodfellow},   year = {2024},   note = {R package version 0.0.1},   url = {https://cmmid.github.io/paramix/}, }"},{"path":"https://cmmid.github.io/paramix/index.html","id":"paramix","dir":"","previous_headings":"","what":"Aggregate and Disaggregate Continuous Parameters for Compartmental Models","title":"Aggregate and Disaggregate Continuous Parameters for Compartmental Models","text":"Tools calculating aggregate parameters disaggregating outcomes.","code":""},{"path":"https://cmmid.github.io/paramix/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Aggregate and Disaggregate Continuous Parameters for Compartmental Models","text":"complex infectious disease compartmental models, may need represent populations groups discretize group continuous feature. example, model might use broad age groups, might higher resolution data critical processes age. ’ve run model, might want outcomes associated processes finer resolution follow analyses. paramix package provides convenient functions create correct aggregate parameters disaggregate outcomes.","code":""},{"path":"https://cmmid.github.io/paramix/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Aggregate and Disaggregate Continuous Parameters for Compartmental Models","text":"","code":"remotes::install_github(\"cmmid/paramix\")"},{"path":"https://cmmid.github.io/paramix/index.html","id":"demo-analysis","dir":"","previous_headings":"","what":"Demo Analysis","title":"Aggregate and Disaggregate Continuous Parameters for Compartmental Models","text":"addition vignette introductory analysis, provide extensive analysis pipeline, divided stages linked together via GNUMake. also need R package renv installed. can create copy pipeline R console: go created copy run make command: result fair bit environment setup (ensure setup reproducibility)","code":"path_to_destination <- file.path(\"~\", \"Downloads\", \"paramixdemo\") # or wherever if (!dir.exists(path_to_destination)) { # if needed, create the directory   dir.create(path_to_destination, recursive = TRUE) } # get the analysis pipeline system.file(\"analysis\", package = \"paramix\") |>   list.files(full.names = TRUE, recursive = FALSE, include.dirs = TRUE) |>   file.copy(     from = _,     to = path_to_destination,     recursive = TRUE   ) # should be a bunch of TRUEs indicating the files copied successfully ~/Downloads/paramixdemo$ make"},{"path":"https://cmmid.github.io/paramix/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Aggregate and Disaggregate Continuous Parameters for Compartmental Models","text":"Briefly, three steps: create translation object (alembic) based parameter function (e.g. infection fatality ratio function age), density distribution pertinent feature (e.g. population age pyramid), model partitions feature (e.g. age groups), post-processing partitions feature (e.g. age years). create model parameters (blend) alembic apply alembic model results (distill) impute higher resolution outcomes","code":""},{"path":"https://cmmid.github.io/paramix/reference/alembic.html","id":null,"dir":"Reference","previous_headings":"","what":"Create the Blending and Distilling Object — alembic","title":"Create the Blending and Distilling Object — alembic","text":"Create Blending Distilling Object","code":""},{"path":"https://cmmid.github.io/paramix/reference/alembic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create the Blending and Distilling Object — alembic","text":"","code":"alembic(   f_param,   f_pop,   model_partition,   output_partition,   pars_interp_opts = interpolate_opts(fun = stats::splinefun, kind = \"point\", method =     \"natural\"),   pop_interp_opts = interpolate_opts(fun = stats::approxfun, kind = \"integral\", method =     \"constant\", yleft = 0, yright = 0) )"},{"path":"https://cmmid.github.io/paramix/reference/alembic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create the Blending and Distilling Object — alembic","text":"f_param function, f(x) transforms feature (e.g. age), yield parameter values. Alternatively, data.frame first column feature second parameter; see xy.coords() details. latter, combined pars_interp_opts, defaulting spline interpolation. f_pop like f_param, either density function (though integrate 1 like pdf) data.frame values. latter, treated series populations within intervals, interpolated pop_interp_opts create density function. model_partition numeric vector cut points, define partitioning used model output_partition partition underlying feature pars_interp_opts list, minimally element fun, corresponding interpolation function. Defaults splinefun() \"natural\" interpolation. pop_interp_opts ibid, density. Defaults approxfun() \"constant\" interpolation.","code":""},{"path":"https://cmmid.github.io/paramix/reference/alembic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create the Blending and Distilling Object — alembic","text":"data.table columns model_partition, output_partition, weight relpop. first two columns identify partition lower bounds, model output, values associated ; combination model_partition output_partition forms unique identifier, individually may appear multiple times. Generally, object useful input blend() distill() tools.","code":""},{"path":"https://cmmid.github.io/paramix/reference/alembic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create the Blending and Distilling Object — alembic","text":"","code":"ifr_levin <- function(age_in_years) {   (10^(-3.27 + 0.0524 * age_in_years))/100 } age_limits <- c(seq(0, 69, by = 5), 70, 80, 100) age_pyramid <- data.frame(   from = 0:100, weight = ifelse(0:100 < 65, 1, .99^(0:100-64)) ) # flat age distribution, then 1% annual deaths ifr_alembic <- alembic(ifr_levin, age_pyramid, age_limits, 0:100) #> Error in to_function(f_pop, range(overall_partition), pop_interp_opts): for integral data, the final entry should be 0; got instead: 0.696413218049573"},{"path":"https://cmmid.github.io/paramix/reference/blend.html","id":null,"dir":"Reference","previous_headings":"","what":"Blend Parameters — blend","title":"Blend Parameters — blend","text":"blend extracts aggregate parameters alembic object.","code":""},{"path":"https://cmmid.github.io/paramix/reference/blend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Blend Parameters — blend","text":"","code":"blend(alembic_dt)"},{"path":"https://cmmid.github.io/paramix/reference/blend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Blend Parameters — blend","text":"alembic_dt alembic() return value","code":""},{"path":"https://cmmid.github.io/paramix/reference/blend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Blend Parameters — blend","text":"data.table two columns: model_partition (partition lower bounds) value (parameter values partitions)","code":""},{"path":"https://cmmid.github.io/paramix/reference/blend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Blend Parameters — blend","text":"","code":"ifr_levin <- function(age_in_years) {   (10^(-3.27 + 0.0524 * age_in_years))/100 } age_limits <- c(seq(0, 69, by = 5), 70, 80, 100) age_pyramid <- data.frame(   from = 0:99, weight = ifelse(0:99 < 65, 1, .99^(0:99-64)) ) # flat age distribution, then 1% annual deaths alembic_dt <- alembic(ifr_levin, age_pyramid, age_limits, 0:100) #> Warning: data may not support bounds: upper bound 0 > last column 1 entry 0 #> Error in to_function(f_pop, range(overall_partition), pop_interp_opts): for integral data, the final entry should be 0; got instead: 0.703447694999569  ifr_blend <- blend(alembic_dt) #> Error: object 'alembic_dt' not found # the actual function plot(   60:100, ifr_levin(60:100),   xlab = \"age (years)\", ylab = \"IFR\", type = \"l\" ) # the properly aggregated blocks lines(   age_limits, c(ifr_blend$value, tail(ifr_blend$value, 1)),   type = \"s\", col = \"dodgerblue\" ) #> Error: object 'ifr_blend' not found # naively aggregated blocks ifr_naive <- ifr_levin(head(age_limits, -1) + diff(age_limits)/2) lines(   age_limits, c(ifr_naive, tail(ifr_naive, 1)),   type = \"s\", col = \"firebrick\" )  # properly aggregated, but not accounting for age distribution bad_alembic_dt <- alembic(   ifr_levin, within(age_pyramid, weight <- 1), age_limits, 0:100 ) #> Warning: data may not support bounds: upper bound 0 > last column 1 entry 0 #> Error in to_function(f_pop, range(overall_partition), pop_interp_opts): for integral data, the final entry should be 0; got instead: 1 ifr_unif <- blend(bad_alembic_dt) #> Error: object 'bad_alembic_dt' not found lines(   age_limits, c(ifr_unif$value, tail(ifr_unif$value, 1)),   type = \"s\", col = \"darkgreen\" ) #> Error: object 'ifr_unif' not found"},{"path":"https://cmmid.github.io/paramix/reference/distill.html","id":null,"dir":"Reference","previous_headings":"","what":"Distill Outcomes — distill","title":"Distill Outcomes — distill","text":"distill takes low-age resolution outcome, example deaths, proportionally distributes outcome higher age resolution use subsequent analyses like years-life-lost style calculations.","code":""},{"path":"https://cmmid.github.io/paramix/reference/distill.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distill Outcomes — distill","text":"","code":"distill(alembic_dt, outcomes_dt, groupcol = names(outcomes_dt)[1])"},{"path":"https://cmmid.github.io/paramix/reference/distill.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distill Outcomes — distill","text":"alembic_dt alembic() return value outcomes_dt long-format data.frame column either named model_from column value (columns silently ignored) groupcol string, name outcome model group column. outcomes_dt[[groupcol]] column must match model_partition lower bounds, provided constructing alembic_dt alembic().","code":""},{"path":"https://cmmid.github.io/paramix/reference/distill.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distill Outcomes — distill","text":"data.frame, output_partition recalculated value column","code":""},{"path":"https://cmmid.github.io/paramix/reference/distill.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Distill Outcomes — distill","text":"value column re-calculated, note aggregate rows matching groupcol entries outcomes_dt. need group features input data (e.g. need distill outcomes across multiple simulation outputs multiple time points), done external grouping calling distill().","code":""},{"path":"https://cmmid.github.io/paramix/reference/distill.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distill Outcomes — distill","text":"","code":"ifr_levin <- function(age_in_years) {   (10^(-3.27 + 0.0524 * age_in_years))/100 } age_limits <- c(seq(0, 69, by = 5), 70, 80, 100) age_pyramid <- data.table(   from = 0:99, weight = ifelse(0:99 < 65, 1, .99^(0:99-64)) ) # flat age distribution, then 1% annual deaths alembic_dt <- alembic(ifr_levin, age_pyramid, age_limits, 0:100) #> Warning: data may not support bounds: upper bound 0 > last column 1 entry 0 #> Error in to_function(f_pop, range(overall_partition), pop_interp_opts): for integral data, the final entry should be 0; got instead: 0.703447694999569  results <- data.table(model_partition = head(age_limits, -1))[, value := 10] distill(alembic_dt, results) #> Error: object 'alembic_dt' not found"},{"path":"https://cmmid.github.io/paramix/reference/distill_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Distillation Calculation Comparison Summary — distill_summary","title":"Distillation Calculation Comparison Summary — distill_summary","text":"Implements several approaches imputing higher resolution outcomes, tables convenient plotting.","code":""},{"path":"https://cmmid.github.io/paramix/reference/distill_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distillation Calculation Comparison Summary — distill_summary","text":"","code":"distill_summary(alembic_dt, outcomes_dt, groupcol = names(outcomes_dt)[1])"},{"path":"https://cmmid.github.io/paramix/reference/distill_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distillation Calculation Comparison Summary — distill_summary","text":"alembic_dt alembic() return value outcomes_dt long-format data.frame column either named model_from column value (columns silently ignored) groupcol string, name outcome model group column. outcomes_dt[[groupcol]] column must match model_partition lower bounds, provided constructing alembic_dt alembic().","code":""},{"path":"https://cmmid.github.io/paramix/reference/distill_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distillation Calculation Comparison Summary — distill_summary","text":"data.table, columns: partition, feature point corresponding value value, translated outcomes_dt$value method, factor levels indicating feature points selected, value weighted features: f_mid: features alembic_dt outcome partitions, value corresponding total value corresponding model partition, divided number outcome partitions model partition f_mean: ... mean_f: ... wm_f: ","code":""},{"path":"https://cmmid.github.io/paramix/reference/distill_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distillation Calculation Comparison Summary — distill_summary","text":"","code":"library(data.table) f_param <- function(age_in_years) {   (10^(-3.27 + 0.0524 * age_in_years))/100 }  model_partition <- c(0, 5, 20, 65, 101) density_dt <- data.table(   from = 0:101, weight = c(rep(1, 66), exp(-0.075 * 1:35), 0) ) alembic_dt <- alembic(   f_param, density_dt, model_partition, seq(0, 101, by = 1L) )  # for simplicity, assume a uniform force-of-infection across ages => # infections proportion to population density. model_outcomes_dt <- density_dt[from != max(from), .(value = sum(f_param(from) * weight)),   by = .(model_from = model_partition[findInterval(from, model_partition)]) ]  ds_dt <- distill_summary(alembic_dt, model_outcomes_dt)"},{"path":"https://cmmid.github.io/paramix/reference/interpolate_opts.html","id":null,"dir":"Reference","previous_headings":"","what":"Interpolation Options — interpolate_opts","title":"Interpolation Options — interpolate_opts","text":"Creates interpolation options object use alembic().","code":""},{"path":"https://cmmid.github.io/paramix/reference/interpolate_opts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interpolation Options — interpolate_opts","text":"","code":"interpolate_opts(fun, kind = c(\"point\", \"integral\"), ...)"},{"path":"https://cmmid.github.io/paramix/reference/interpolate_opts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interpolation Options — interpolate_opts","text":"fun function kind string; either \"point\" \"integral\". interpret x, y values interpolated. Either point observations function integral function interval. ... arbitrary arguments, checked signature fun","code":""},{"path":"https://cmmid.github.io/paramix/reference/interpolate_opts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interpolation Options — interpolate_opts","text":"list, fun kind keys, well whatever valid keys appear ....","code":""},{"path":"https://cmmid.github.io/paramix/reference/interpolate_opts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interpolation Options — interpolate_opts","text":"method creates interpolation object use alembic(); convenience method, basic validation arguments ensures information used alembic() interpolation available. ... arguments provided fun invoked interpolate tabular \"functional\" form arguments alembic(). fun argument kind, parameter also passed invoking function; , input data transformed \\(\\{x, z\\}\\) pairs, \\(x_{+1}-x_{} * z_i = y_i\\) - .e., transforming point value functional form assumed constant next partition.","code":""},{"path":"https://cmmid.github.io/paramix/reference/interpolate_opts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interpolation Options — interpolate_opts","text":"","code":"interpolate_opts(   fun = stats::splinefun, method = \"natural\", kind = \"point\" ) #> $fun #> function (x, y = NULL, method = c(\"fmm\", \"periodic\", \"natural\",  #>     \"monoH.FC\", \"hyman\"), ties = mean)  #> { #>     x <- regularize.values(x, y, ties, missing(ties)) #>     y <- x$y #>     x <- x$x #>     nx <- length(x) #>     if (is.na(nx))  #>         stop(gettextf(\"invalid value of %s\", \"length(x)\"), domain = NA) #>     if (nx == 0)  #>         stop(\"zero non-NA points\") #>     method <- match.arg(method) #>     if (method == \"periodic\" && y[1L] != y[nx]) { #>         warning(\"spline: first and last y values differ - using y[1L] for both\") #>         y[nx] <- y[1L] #>     } #>     if (method == \"monoH.FC\") { #>         n1 <- nx - 1L #>         dy <- y[-1L] - y[-nx] #>         dx <- x[-1L] - x[-nx] #>         Sx <- dy/dx #>         m <- c(Sx[1L], (Sx[-1L] + Sx[-n1])/2, Sx[n1]) #>         m <- .Call(C_monoFC_m, m, Sx) #>         return(splinefunH0(x0 = x, y0 = y, m = m, dx = dx)) #>     } #>     iMeth <- match(method, c(\"periodic\", \"natural\", \"fmm\", \"monoH.FC\",  #>         \"hyman\")) #>     if (iMeth == 5L) { #>         dy <- diff(y) #>         if (!(all(dy >= 0) || all(dy <= 0)))  #>             stop(\"'y' must be increasing or decreasing\") #>     } #>     z <- .Call(C_SplineCoef, min(3L, iMeth), x, y) #>     if (iMeth == 5L)  #>         z <- spl_coef_conv(hyman_filter(z)) #>     rm(x, y, nx, method, iMeth, ties) #>     function(x, deriv = 0L) { #>         deriv <- as.integer(deriv) #>         if (deriv < 0L || deriv > 3L)  #>             stop(\"'deriv' must be between 0 and 3\") #>         if (deriv > 0L) { #>             z0 <- double(z$n) #>             z[c(\"y\", \"b\", \"c\")] <- switch(deriv, list(y = z$b,  #>                 b = 2 * z$c, c = 3 * z$d), list(y = 2 * z$c,  #>                 b = 6 * z$d, c = z0), list(y = 6 * z$d, b = z0,  #>                 c = z0)) #>             z[[\"d\"]] <- z0 #>         } #>         res <- .splinefun(x, z) #>         if (deriv > 0 && z$method == 2 && any(ind <- x <= z$x[1L]))  #>             res[ind] <- ifelse(deriv == 1, z$y[1L], 0) #>         res #>     } #> } #> <bytecode: 0x556335146720> #> <environment: namespace:stats> #>  #> $kind #> [1] \"point\" #>  #> $.usekind #> [1] FALSE #>  #> $method #> [1] \"natural\" #>  interpolate_opts(   fun = stats::approxfun, method = \"constant\", yleft = 0, yright = 0,   kind = \"integral\" ) #> $fun #> function (x, y = NULL, method = \"linear\", yleft, yright, rule = 1,  #>     f = 0, ties = mean, na.rm = TRUE)  #> { #>     method <- pmatch(method, c(\"linear\", \"constant\")) #>     if (is.na(method))  #>         stop(\"invalid interpolation method\") #>     stopifnot(is.numeric(rule), (lenR <- length(rule)) >= 1L,  #>         lenR <= 2L) #>     if (lenR == 1)  #>         rule <- rule[c(1, 1)] #>     x <- regularize.values(x, y, ties, missing(ties), na.rm = na.rm) #>     nx <- if (na.rm || !x$keptNA)  #>         length(x$x) #>     else sum(x$notNA) #>     if (is.na(nx))  #>         stop(\"invalid length(x)\") #>     if (nx <= 1) { #>         if (method == 1)  #>             stop(\"need at least two non-NA values to interpolate\") #>         if (nx == 0)  #>             stop(\"zero non-NA points\") #>     } #>     y <- x$y #>     if (missing(yleft))  #>         yleft <- if (rule[1L] == 1)  #>             NA #>         else y[1L] #>     if (missing(yright))  #>         yright <- if (rule[2L] == 1)  #>             NA #>         else y[length(y)] #>     stopifnot(length(yleft) == 1L, length(yright) == 1L, length(f) ==  #>         1L) #>     rm(rule, ties, lenR, nx) #>     x <- as.double(x$x) #>     y <- as.double(y) #>     .Call(C_ApproxTest, x, y, method, f, na.rm) #>     function(v) .approxfun(x, y, v, method, yleft, yright, f,  #>         na.rm) #> } #> <bytecode: 0x55633462bc20> #> <environment: namespace:stats> #>  #> $kind #> [1] \"integral\" #>  #> $.usekind #> [1] FALSE #>  #> $method #> [1] \"constant\" #>  #> $yleft #> [1] 0 #>  #> $yright #> [1] 0 #>"},{"path":"https://cmmid.github.io/paramix/reference/make_partition.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Least-Common-Interval Partition — make_partition","title":"Create a Least-Common-Interval Partition — make_partition","text":"Internal utility method creating partitions, possibly multiple distinct partitions. Validates inputs.","code":""},{"path":"https://cmmid.github.io/paramix/reference/make_partition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Least-Common-Interval Partition — make_partition","text":"","code":"make_partition(model_partition = numeric(0), output_partition = numeric(0))"},{"path":"https://cmmid.github.io/paramix/reference/make_partition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Least-Common-Interval Partition — make_partition","text":"model_partition model partition output_partition output partition","code":""},{"path":"https://cmmid.github.io/paramix/reference/make_partition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Least-Common-Interval Partition — make_partition","text":"sorted numeric vector unique values","code":""},{"path":"https://cmmid.github.io/paramix/reference/make_weight.html","id":null,"dir":"Reference","previous_headings":"","what":"Compose Parameter & Density Functions — make_weight","title":"Compose Parameter & Density Functions — make_weight","text":"Purely internal, called to_function, direct user arguments.#'","code":""},{"path":"https://cmmid.github.io/paramix/reference/make_weight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compose Parameter & Density Functions — make_weight","text":"","code":"make_weight(f_param, f_pop)"},{"path":"https://cmmid.github.io/paramix/reference/make_weight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compose Parameter & Density Functions — make_weight","text":"f_param function; parameter function, varying aggregate f_pop function; density function, varying aggregate","code":""},{"path":"https://cmmid.github.io/paramix/reference/make_weight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compose Parameter & Density Functions — make_weight","text":"new function, f(x) = f_param(x)*f_pop(x)","code":""},{"path":"https://cmmid.github.io/paramix/reference/parameter_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameter Calculation Comparison Summary — parameter_summary","title":"Parameter Calculation Comparison Summary — parameter_summary","text":"Implements several approaches computing partition-aggregated parameters, tables convenient plotting.","code":""},{"path":"https://cmmid.github.io/paramix/reference/parameter_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parameter Calculation Comparison Summary — parameter_summary","text":"","code":"parameter_summary(f_param, f_pop, model_partition, resolution = 101L)"},{"path":"https://cmmid.github.io/paramix/reference/parameter_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parameter Calculation Comparison Summary — parameter_summary","text":"f_param function, f(x) transforms feature (e.g. age), yield parameter values. Alternatively, data.frame first column feature second parameter; see xy.coords() details. latter, combined pars_interp_opts, defaulting spline interpolation. f_pop like f_param, either density function (though integrate 1 like pdf) data.frame values. latter, treated series populations within intervals, interpolated pop_interp_opts create density function. model_partition numeric vector cut points, define partitioning used model resolution number points calculate underlying f_param function. default 101 points means 100 partitions.","code":""},{"path":"https://cmmid.github.io/paramix/reference/parameter_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parameter Calculation Comparison Summary — parameter_summary","text":"data.table, columns: model_category, integer corresponding intervals model_partition x value x, numeric series first last elements model_partition length resolution method, factor levels: f_val: f_param(x) f_mid: f_param(x_mid), x_mid midpoint x model_category f_mean: f_param(weighted.mean(x, w)), w defined densities model_category mean_f: weighted.mean(f_param(x), w), previous wm_f: result used paramix::blend(); similar mean_f, though slightly different since blend uses integrate()","code":""},{"path":"https://cmmid.github.io/paramix/reference/parameter_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parameter Calculation Comparison Summary — parameter_summary","text":"","code":"# COVID IFR from Levin et al 2020 https://doi.org/10.1007/s10654-020-00698-1 f_param <- function(age_in_years) {   (10^(-3.27 + 0.0524 * age_in_years))/100 }  densities <- data.frame(   from = 0:101,   weight = c(rep(1, 66), exp(-0.075 * 1:35), 0) )  model_partition <- c(0, 5, 20, 65, 101)  ps_dt <- parameter_summary(f_param, densities, model_partition) ps_dt #>      model_category      x method        value #>               <int>  <num> <fctr>        <num> #>   1:              1   0.00  f_val 5.370318e-06 #>   2:              1   1.01  f_val 6.066302e-06 #>   3:              1   2.02  f_val 6.852484e-06 #>   4:              1   3.03  f_val 7.740553e-06 #>   5:              1   4.04  f_val 8.743715e-06 #>  ---                                           #> 501:              4  96.96   wm_f 1.006082e-01 #> 502:              4  97.97   wm_f 1.006082e-01 #> 503:              4  98.98   wm_f 1.006082e-01 #> 504:              4  99.99   wm_f 1.006082e-01 #> 505:              4 101.00   wm_f 1.006082e-01  ggplot(ps_dt) + aes(x, y = value, color = method) +   geom_line(data = \\(dt) subset(dt, method == \"f_val\")) +   geom_step(data = \\(dt) subset(dt, method != \"f_val\")) +   theme_bw() + theme(     legend.position = \"inside\", legend.position.inside = c(0.05, 0.95),     legend.justification = c(0, 1)   ) + scale_color_discrete(     \"Method\", labels = c(       f_val = \"f(x)\", f_mid = \"f(mid(x))\", f_mean = \"f(E[x])\",       mean_f = \"discrete E[f(x)]\", wm_f = \"integrated E[f(x)]\"     )   ) +   scale_x_continuous(\"Age\", breaks = seq(0, 100, by = 10)) +   scale_y_log10(\"IFR\", breaks = 10^c(-6, -4, -2, 0), limits = 10^c(-6, 0)) #> Warning: Removed 1 row containing missing values or values outside the scale range #> (`geom_line()`)."},{"path":"https://cmmid.github.io/paramix/reference/paramix-package.html","id":null,"dir":"Reference","previous_headings":"","what":"paramix: Aggregate and Disaggregate Continuous Parameters for Compartmental Models — paramix-package","title":"paramix: Aggregate and Disaggregate Continuous Parameters for Compartmental Models — paramix-package","text":"convenient framework aggregating disaggregating continuously varying parameters (example, case fatality ratio, age) proper parametrization lower-resolution compartmental models (example, broad age categories) subsequent upscaling model outputs high resolution (example, needed calculating age-sensitive measures like years-life-lost).","code":""},{"path":[]},{"path":"https://cmmid.github.io/paramix/reference/paramix-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"paramix: Aggregate and Disaggregate Continuous Parameters for Compartmental Models — paramix-package","text":"Maintainer: Carl Pearson carl.ab.pearson@gmail.com (ORCID) Authors: Simon Proctor simon.procter@lshtm.ac.uk (ORCID) Lucy Goodfellow lucy.goodfellow@lshtm.ac.uk (ORCID)","code":""},{"path":"https://cmmid.github.io/paramix/reference/to_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Conversion of Data to Function — to_function","title":"Internal Conversion of Data to Function — to_function","text":"Internal Conversion Data Function","code":""},{"path":"https://cmmid.github.io/paramix/reference/to_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Conversion of Data to Function — to_function","text":"","code":"to_function(x, bounds, interp_opts)"},{"path":"https://cmmid.github.io/paramix/reference/to_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Conversion of Data to Function — to_function","text":"x function single argument version x xy.coords() (per approxfun() splinefun() inputs). Pass user input, must checked bounds numeric vector, length 2: partition lower bound; checked, result range(make_partition(...)). interp_opts x function, ignored. Otherwise, interpolating function arguments.","code":""},{"path":"https://cmmid.github.io/paramix/reference/to_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Conversion of Data to Function — to_function","text":"function","code":""}]
