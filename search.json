[{"path":"https://cmmid.github.io/paramix/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 paramix authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://cmmid.github.io/paramix/articles/intro.html","id":"motivating-example","dir":"Articles","previous_headings":"","what":"Motivating Example","title":"Introductory Usage: `paramix`","text":"SARS-COV-2 pathogen causes COVID-19, distinctly age-specific mortality. meta-analysis, Levin et al1 estimated age-specific infection-fatality ratio (IFR) COVID-19 :  evaluate threat infectious disease, researchers often calculate expected “years life lost” (YLLs). Based age-specific mortality data, can estimate many years individuals various ages can expect live. People die modelled illness lose corresponding number years life, depending age death. vignette, turn continuous IFR relationship compartmental aggregate IFR deaths broader age groups, back age-specific deaths, use estimate YLLs.","code":"ifr_levin <- function(age_in_years) {   (10^(-3.27 + 0.0524 * age_in_years))/100 }"},{"path":"https://cmmid.github.io/paramix/articles/intro.html","id":"parametrizing-a-compartmental-model","dir":"Articles","previous_headings":"","what":"Parametrizing a Compartmental Model","title":"Introductory Usage: `paramix`","text":"Typically, ODE compartmental models low-resolution stratification combining several ages mix computational reasons, data-availability interactions like contact patterns, match intervention targets (e.g. vaccinating children versus working age adults versus retirees). mixing several ages single compartment, properly aggregated value parameters like IFR? Generally, E[f(x)]≠f(E[x])E\\left[f\\left(x\\right)\\right] \\ne f\\left(E\\left[x\\right]\\right), using IFR mean age compartment guaranteed correct. average IFR age range reasonable, assumes uniform distribution individuals age, generally true. proper average IFR needs weighted age distribution, : IFR|ab=∫abIFR(age)ρ(age)dage∫abρ(age)dage \\textrm{IFR}\\Big\\rvert_a^b = \\frac{\\int_a^b \\textrm{IFR}(\\textrm{age})\\rho(\\textrm{age})d\\textrm{age}}{\\int_a^b \\rho(\\textrm{age})d\\textrm{age}} can compare various calculations IFR two different population age distributions: Afghanistan United Kingdom. Recall, considered using: average age function, .e. IFR(+b2)\\textrm{IFR}(\\frac{+b}{2}) function average, assuming uniform age distribution, .e. ∫abIFR(age)dage\\int_a^b \\textrm{IFR}(\\textrm{age}) d\\textrm{age} weighted function average () Let’s imagine compartmental model age groups [0,5), [5,20), [20,65), [65,101], corresponding roughly pre-school age children, school age individuals, prime working age adults, post-working age adults. First, need get relevant values: can calculate IFR values model age group, different approaches computing . ’ll use package function parameter_summary(), provides convenient comparison parameter values approaches summarisation: plotting different blends:  Clearly, different approaches result different mortality outcomes otherwise identical infection patterns.","code":"# our model age group cut points model_agelimits <- c(0, 5, 20, 65, 101) # get select data from World Population Prospects estimates data(\"popF\", package = \"wpp2019\") data(\"popM\", package = \"wpp2019\")  pop_dt <- as.data.table(popF)[,   .(name, age, popF = `2020`) ][   as.data.table(popM), on = c(\"name\", \"age\"),   .(name, age, popF, popM = `2020`) ][, age := as.integer(gsub(\"^(\\\\d+)[-+].*$\",\"\\\\1\", age)) ][   name %like% \"Afghanistan|United Kingdom\" ]  density_dt <- pop_dt[,   .(     name, from = age,     weight = popF + popM   ) ]  rm(popF) rm(popM) plot_dt <- density_dt[, { # compute parameters for each country of interest   paramix::parameter_summary(     f_param = ifr_levin, f_dense = .SD, model_agelimits   ) }, by = name]"},{"path":"https://cmmid.github.io/paramix/articles/intro.html","id":"typical-application","dir":"Articles","previous_headings":"","what":"Typical Application","title":"Introductory Usage: `paramix`","text":"previous section, used convenience method package provides plotting. typically, want use three main functions package: alembic() make weighted mapping one resolution another blend() aggregate associated weighted mixture parameters distill() impute finer scale outcomes model outputs Revisiting previous example, properly age-weighted IFRs look like: parameters now weighted correctly use model age groups underlying populations. run model, might want disaggregate outcome, example converting deaths years life lost. example, since IFR increases age, deaths occurring wide age group likely occurred older end age group. can compare approaches calculating distribution deaths: assume deaths occur middle age age group, uniformly within age group, proportional age distribution within group, proportional age relative mortality rates. last option, can use Bayes’ theorem calculate correct proportionality: P(Age|Death)=P(Death|Age)P(Age)P(Death) \\textrm{P}\\left(\\textrm{Age} \\vert \\textrm{Death}\\right) = \\frac{\\textrm{P}\\left(\\textrm{Death} \\vert \\textrm{Age}\\right)\\textrm{P}\\left(\\textrm{Age}\\right)}{\\textrm{P}\\left(\\textrm{Death}\\right)} know P(Age)\\textrm{P}\\left(\\textrm{Age}\\right) relative fraction age within age group, P(Death|Age)P(Death)\\frac{\\textrm{P}\\left(\\textrm{Death} \\vert \\textrm{Age}\\right)}{\\textrm{P}\\left(\\textrm{Death}\\right)} relative mortality rate age within age group. can therefore use terms calculate P(Age|Death)\\textrm{P}\\left(\\textrm{Age} \\vert \\textrm{Death}\\right), allocate mortality outcomes accordingly. demonstration purposes, let’s assume one million infections occur proportionally across model population groups2. Using properly-weighted IFR values age group , infections result deaths follows: translate age-specific deaths, based different calculation methods? convenience, paramix can compute approaches mentioned comparison: can see calculations entering paramix::distill_summary (parentheses) R prompt. Plotted, results four different methods calculation look like: combine different deaths--age life expectancy estimates, see differences estimated years life lost. Without necessary adjustments age structure mortality shape, typically overestimate YLLs.","code":"# setup the model to outcome mapping using `alembic`s mapping_dt <- density_dt[,   paramix::alembic(     f_param = ifr_levin, f_dense = .SD,     model_partition = model_agelimits,     output_partition = seq(min(from), max(from) + 1L, by = 5L)   ),   by = name ]  params <- mapping_dt[, paramix::blend(.SD), by = name] model_density_dt <- density_dt[, .(   model_from = model_agelimits[findInterval(from, model_agelimits)],   weight ), by = name][, .(weight = sum(weight)), by = .(name, model_from)][,   weight := weight / sum(weight), by = name ] model_deaths_dt <- model_density_dt[   params, on = .(name, model_from) ][,   .(name, model_from, deaths = weight * 1e6 * value) ] distill_methods_dt <- model_deaths_dt[,   paramix::distill_summary(     .SD[, .(model_from, value = deaths)],     mapping_dt[name == .BY]   ),   by = name ] #> Warning: Removed 2 rows containing missing values or values outside the scale range #> (`geom_bar()`)."},{"path":"https://cmmid.github.io/paramix/articles/intro.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Introductory Usage: `paramix`","text":"Properly blending distilling parameter values can make relatively large difference estimating outcomes non-linear, example years-life-lost. package can make correctly relatively easy.","code":""},{"path":"https://cmmid.github.io/paramix/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Carl Pearson. Author, maintainer. Simon Proctor. Author. Lucy Goodfellow. Author.","code":""},{"path":"https://cmmid.github.io/paramix/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Pearson C, Proctor S, Goodfellow L (2024). paramix: Aggregate Disaggregate Continuous Parameters Compartmental Models. R package version 0.0.1, https://cmmid.github.io/paramix/.","code":"@Manual{,   title = {paramix: Aggregate and Disaggregate Continuous Parameters for Compartmental Models},   author = {Carl Pearson and Simon Proctor and Lucy Goodfellow},   year = {2024},   note = {R package version 0.0.1},   url = {https://cmmid.github.io/paramix/}, }"},{"path":"https://cmmid.github.io/paramix/index.html","id":"paramix","dir":"","previous_headings":"","what":"Aggregate and Disaggregate Continuous Parameters for Compartmental Models","title":"Aggregate and Disaggregate Continuous Parameters for Compartmental Models","text":"Tools calculating aggregate parameters disaggregating outcomes.","code":""},{"path":"https://cmmid.github.io/paramix/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Aggregate and Disaggregate Continuous Parameters for Compartmental Models","text":"complex infectious disease compartmental models, may need represent populations groups discretize group continuous feature. example, model might use broad age groups, might higher resolution data critical processes age. ’ve run model, might want outcomes associated processes finer resolution follow analyses. paramix package provides convenient functions create correct aggregate parameters disaggregate outcomes.","code":""},{"path":"https://cmmid.github.io/paramix/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Aggregate and Disaggregate Continuous Parameters for Compartmental Models","text":"","code":"remotes::install_github(\"cmmid/paramix\")"},{"path":"https://cmmid.github.io/paramix/index.html","id":"demo-analysis","dir":"","previous_headings":"","what":"Demo Analysis","title":"Aggregate and Disaggregate Continuous Parameters for Compartmental Models","text":"addition vignette introductory analysis, provide extensive analysis pipeline, divided stages linked together via GNUMake. also need R package renv installed. can create copy pipeline R console: go created copy run make command: result fair bit environment setup (ensure setup reproducibility)","code":"path_to_destination <- file.path(\"~\", \"Downloads\", \"paramixdemo\") # or wherever if (!dir.exists(path_to_destination)) { # if needed, create the directory   dir.create(path_to_destination, recursive = TRUE) } # get the analysis pipeline system.file(\"analysis\", package = \"paramix\") |>   list.files(full.names = TRUE, recursive = FALSE, include.dirs = TRUE) |>   file.copy(     from = _,     to = path_to_destination,     recursive = TRUE   ) # should be a bunch of TRUEs indicating the files copied successfully ~/Downloads/paramixdemo$ make"},{"path":"https://cmmid.github.io/paramix/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Aggregate and Disaggregate Continuous Parameters for Compartmental Models","text":"Briefly, three steps: create translation object (alembic) based parameter function (e.g. infection fatality ratio function age), density distribution pertinent feature (e.g. population age pyramid), model partitions feature (e.g. age groups), post-processing partitions feature (e.g. age years). create model parameters (blend) alembic apply alembic model results (distill) impute higher resolution outcomes","code":""},{"path":"https://cmmid.github.io/paramix/reference/alembic.html","id":null,"dir":"Reference","previous_headings":"","what":"Create the Blending and Distilling Object — alembic","title":"Create the Blending and Distilling Object — alembic","text":"Create Blending Distilling Object","code":""},{"path":"https://cmmid.github.io/paramix/reference/alembic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create the Blending and Distilling Object — alembic","text":"","code":"alembic(   f_param,   f_dense,   model_partition,   output_partition,   pars_interp_opts = list(fun = stats::splinefun, method = \"natural\"),   dens_interp_opts = list(fun = stats::approxfun, method = \"constant\", yleft = 0, yright     = 0) )"},{"path":"https://cmmid.github.io/paramix/reference/alembic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create the Blending and Distilling Object — alembic","text":"f_param function, f(x) transforms feature (e.g. age), yields parameter value. Alternatively, data.frame first column feature (x) second parameter (y); see xy.coords() details. latter, combined pars_interp_opts, defaulting spline interpolation. f_dense like f_param, either density function (though integrate 1 like pdf) data.frame values. latter, combined dens_interp_opts defaulting constant density x next. model_partition numeric vector cut points, define partitioning used model output_partition partition underlying feature pars_interp_opts list, minimally element fun, corresponding interpolation function. Defaults splinefun() \"natural\" interpolation dens_interp_opts ibid, density. Defaults approxfun() \"constant\" interpolation","code":""},{"path":"https://cmmid.github.io/paramix/reference/alembic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create the Blending and Distilling Object — alembic","text":"data.frame maps fractions original model partitions desired partitions, according underlying relative outcome rates densities","code":""},{"path":"https://cmmid.github.io/paramix/reference/alembic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create the Blending and Distilling Object — alembic","text":"","code":"ifr_levin <- function(age_in_years) {   (10^(-3.27 + 0.0524 * age_in_years))/100 } age_limits <- c(seq(0, 69, by = 5), 70, 80, 100) age_pyramid <- data.frame(   from = 0:100, weight = ifelse(0:100 < 65, 1, .99^(0:100-64)) ) # flat age distribution, then 1% annual deaths ifr_alembic <- alembic(ifr_levin, age_pyramid, age_limits, 0:100)"},{"path":"https://cmmid.github.io/paramix/reference/blend.html","id":null,"dir":"Reference","previous_headings":"","what":"Blend Parameters — blend","title":"Blend Parameters — blend","text":"blend extracts aggregate parameters alembic object.","code":""},{"path":"https://cmmid.github.io/paramix/reference/blend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Blend Parameters — blend","text":"","code":"blend(alembic_dt)"},{"path":"https://cmmid.github.io/paramix/reference/blend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Blend Parameters — blend","text":"alembic_dt alembic() return value","code":""},{"path":"https://cmmid.github.io/paramix/reference/blend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Blend Parameters — blend","text":"data.table two columns: model_from (partition lower bounds) value (parameter values partitions)","code":""},{"path":"https://cmmid.github.io/paramix/reference/blend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Blend Parameters — blend","text":"","code":"ifr_levin <- function(age_in_years) {   (10^(-3.27 + 0.0524 * age_in_years))/100 } age_limits <- c(seq(0, 69, by = 5), 70, 80, 100) age_pyramid <- data.frame(   from = 0:99, weight = ifelse(0:99 < 65, 1, .99^(0:99-64)) ) # flat age distribution, then 1% annual deaths alembic_dt <- alembic(ifr_levin, age_pyramid, age_limits, 0:100)  ifr_blend <- blend(alembic_dt) # the actual function plot(   60:100, ifr_levin(60:100),   xlab = \"age (years)\", ylab = \"IFR\", type = \"l\" ) # the properly aggregated blocks lines(   age_limits, c(ifr_blend$value, tail(ifr_blend$value, 1)),   type = \"s\", col = \"dodgerblue\" ) # naively aggregated blocks ifr_naive <- ifr_levin(head(age_limits, -1) + diff(age_limits)/2) lines(   age_limits, c(ifr_naive, tail(ifr_naive, 1)),   type = \"s\", col = \"firebrick\" ) # properly aggregated, but not accounting for age distribution bad_alembic_dt <- alembic(   ifr_levin, within(age_pyramid, weight <- 1), age_limits, 0:100 ) ifr_unif <- blend(bad_alembic_dt) lines(   age_limits, c(ifr_unif$value, tail(ifr_unif$value, 1)),   type = \"s\", col = \"darkgreen\" )"},{"path":"https://cmmid.github.io/paramix/reference/distill.html","id":null,"dir":"Reference","previous_headings":"","what":"Distill Outcomes — distill","title":"Distill Outcomes — distill","text":"distill takes low-age resolution outcome, example deaths, proportionally distributes outcome higher age resolution use subsequent analyses like years-life-lost style calculations.","code":""},{"path":"https://cmmid.github.io/paramix/reference/distill.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distill Outcomes — distill","text":"","code":"distill(alembic_dt, outcomes_dt)"},{"path":"https://cmmid.github.io/paramix/reference/distill.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distill Outcomes — distill","text":"alembic_dt alembic() return value outcomes_dt long-format data.frame column either named model_from column value (columns silently ignored)","code":""},{"path":"https://cmmid.github.io/paramix/reference/distill.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distill Outcomes — distill","text":"data.frame, new_from recalculated value column","code":""},{"path":"https://cmmid.github.io/paramix/reference/distill.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Distill Outcomes — distill","text":"value column re-calculated, note aggregate matching / model_from rows outcomes_dt. need group features input data (e.g. need distill outcomes across multiple simulation outputs), done outside call distill().","code":""},{"path":"https://cmmid.github.io/paramix/reference/distill_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Distillation Calculation Comparison Summary — distill_summary","title":"Distillation Calculation Comparison Summary — distill_summary","text":"Implements several approaches imputing higher resolution outcomes, tables convenient plotting.","code":""},{"path":"https://cmmid.github.io/paramix/reference/distill_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distillation Calculation Comparison Summary — distill_summary","text":"","code":"distill_summary(model_outcomes_dt, alembic_dt)"},{"path":"https://cmmid.github.io/paramix/reference/distill_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distillation Calculation Comparison Summary — distill_summary","text":"model_outcomes_dt data.table (convertable ) columns model_from value alembic_dt alembic() return value","code":""},{"path":"https://cmmid.github.io/paramix/reference/distill_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distillation Calculation Comparison Summary — distill_summary","text":"data.table, columns: partition, feature point corresponding value value, translated model_outcomes_dt$value method, factor levels indicating feature points selected, value weighted features: f_mid: features alembic_dt outcome partitions, value corresponding total value corresponding model partition, divided number outcome partitions model partition f_mean: ... mean_f: ... wm_f: ","code":""},{"path":"https://cmmid.github.io/paramix/reference/distill_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distillation Calculation Comparison Summary — distill_summary","text":"","code":"library(data.table) f_param <- function(age_in_years) {   (10^(-3.27 + 0.0524 * age_in_years))/100 }  model_partition <- c(0, 5, 20, 65, 101) density_dt <- data.table(   from = 0:100, weight = c(rep(1, 66), exp(-0.075 * 1:35)) ) alembic_dt <- alembic(   f_param, density_dt, model_partition, seq(0, 101, by = 1L) )  # for simplicity, assume a uniform force-of-infection across ages => # infections proportion to population density. model_outcomes_dt <- density_dt[, .(value = sum(f_param(from) * weight)),   by = .(model_from = model_partition[findInterval(from, model_partition)]) ]  ds_dt <- distill_summary(model_outcomes_dt, alembic_dt)"},{"path":"https://cmmid.github.io/paramix/reference/make_partition.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Least-Common-Interval Partition — make_partition","title":"Create a Least-Common-Interval Partition — make_partition","text":"Internal utility method creating partitions, possibly multiple distinct partitions. Validates inputs potential creates open ends.","code":""},{"path":"https://cmmid.github.io/paramix/reference/make_partition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Least-Common-Interval Partition — make_partition","text":"","code":"make_partition(...)"},{"path":"https://cmmid.github.io/paramix/reference/make_partition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Least-Common-Interval Partition — make_partition","text":"... number numeric vectors","code":""},{"path":"https://cmmid.github.io/paramix/reference/make_partition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Least-Common-Interval Partition — make_partition","text":"sorted numeric vector unique values","code":""},{"path":"https://cmmid.github.io/paramix/reference/make_weight.html","id":null,"dir":"Reference","previous_headings":"","what":"Compose Parameter & Density Functions — make_weight","title":"Compose Parameter & Density Functions — make_weight","text":"Compose Parameter & Density Functions","code":""},{"path":"https://cmmid.github.io/paramix/reference/make_weight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compose Parameter & Density Functions — make_weight","text":"","code":"make_weight(f_param, f_dense)"},{"path":"https://cmmid.github.io/paramix/reference/make_weight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compose Parameter & Density Functions — make_weight","text":"f_param function; parameter function, varying aggregate f_dense function; density function, varying aggregate","code":""},{"path":"https://cmmid.github.io/paramix/reference/make_weight.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compose Parameter & Density Functions — make_weight","text":"new function, f(x) = f_param(x)*f_density(x)","code":""},{"path":"https://cmmid.github.io/paramix/reference/parameter_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameter Calculation Comparison Summary — parameter_summary","title":"Parameter Calculation Comparison Summary — parameter_summary","text":"Implements several approaches computing partition-aggregated parameters, tables convenient plotting.","code":""},{"path":"https://cmmid.github.io/paramix/reference/parameter_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parameter Calculation Comparison Summary — parameter_summary","text":"","code":"parameter_summary(   f_param,   f_dense,   model_partition,   resolution = diff(range(model_partition)) + 1L )"},{"path":"https://cmmid.github.io/paramix/reference/parameter_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parameter Calculation Comparison Summary — parameter_summary","text":"f_param function, f(x) transforms feature (e.g. age), yields parameter value. Alternatively, data.frame first column feature (x) second parameter (y); see xy.coords() details. latter, combined pars_interp_opts, defaulting spline interpolation. f_dense like f_param, either density function (though integrate 1 like pdf) data.frame values. latter, combined dens_interp_opts defaulting constant density x next. model_partition numeric vector cut points, define partitioning used model resolution number points calculate underlying f_param function.","code":""},{"path":"https://cmmid.github.io/paramix/reference/parameter_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parameter Calculation Comparison Summary — parameter_summary","text":"data.table, columns: model_category, integer corresponding intervals model_partition x value x, numeric series first last elements model_partition length resolution method, factor levels: f_val: f_param(x) f_mid: f_param(x_mid), x_mid midpoint x model_category f_mean: f_param(weighted.mean(x, w)), w defined densities model_category mean_f: weighted.mean(f_param(x), w), previous wm_f: result used paramix::blend(); similar mean_f, though slightly different since blend uses integrate()","code":""},{"path":"https://cmmid.github.io/paramix/reference/parameter_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parameter Calculation Comparison Summary — parameter_summary","text":"","code":"# COVID IFR from Levin et al 2020 https://doi.org/10.1007/s10654-020-00698-1 f_param <- function(age_in_years) {   (10^(-3.27 + 0.0524 * age_in_years))/100 }  densities <- data.frame(   from = 0:100,   weight = c(rep(1, 66), exp(-0.075 * 1:35)) )  model_partition <- c(0, 5, 20, 65, 101)  ps_dt <- parameter_summary(f_param, densities, model_partition) ps_dt #>      model_category     x method        value #>               <int> <num> <fctr>        <num> #>   1:              1     0  f_val 5.370318e-06 #>   2:              1     1  f_val 6.058987e-06 #>   3:              1     2  f_val 6.835968e-06 #>   4:              1     3  f_val 7.712586e-06 #>   5:              1     4  f_val 8.701618e-06 #>  ---                                          #> 501:              4    96   wm_f 9.557924e-02 #> 502:              4    97   wm_f 9.557924e-02 #> 503:              4    98   wm_f 9.557924e-02 #> 504:              4    99   wm_f 9.557924e-02 #> 505:              4   100   wm_f 9.557924e-02  ggplot(ps_dt) + aes(x, y = value, color = method) +   geom_line(data = \\(dt) subset(dt, method == \"f_val\")) +   geom_step(data = \\(dt) subset(dt, method != \"f_val\")) +   theme_bw() + theme(     legend.position = \"inside\", legend.position.inside = c(0.05, 0.95),     legend.justification = c(0, 1)   ) + scale_color_discrete(     \"Method\", labels = c(       f_val = \"f(x)\", f_mid = \"f(mid(x))\", f_mean = \"f(E[x])\",       mean_f = \"discrete E[f(x)]\", wm_f = \"integrated E[f(x)]\"     )   ) +   scale_x_continuous(\"Age\", breaks = seq(0, 100, by = 10)) +   scale_y_log10(\"IFR\", breaks = 10^c(-6, -4, -2, 0), limits = 10^c(-6, 0))"},{"path":"https://cmmid.github.io/paramix/reference/paramix-package.html","id":null,"dir":"Reference","previous_headings":"","what":"paramix: Aggregate and Disaggregate Continuous Parameters for Compartmental Models — paramix-package","title":"paramix: Aggregate and Disaggregate Continuous Parameters for Compartmental Models — paramix-package","text":"convenient framework aggregating disaggregating continuously varying parameters (example, case fatality ratio, age) proper parametrization lower-resolution compartmental models (example, broad age categories) subsequent upscaling model outputs high resolution (example, needed calculating age-sensitive measures like years-life-lost).","code":""},{"path":[]},{"path":"https://cmmid.github.io/paramix/reference/paramix-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"paramix: Aggregate and Disaggregate Continuous Parameters for Compartmental Models — paramix-package","text":"Maintainer: Carl Pearson carl.ab.pearson@gmail.com (ORCID) Authors: Simon Proctor simon.procter@lshtm.ac.uk (ORCID) Lucy Goodfellow lucy.goodfellow@lshtm.ac.uk (ORCID)","code":""},{"path":"https://cmmid.github.io/paramix/reference/to_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal Conversion of Data to Function — to_function","title":"Internal Conversion of Data to Function — to_function","text":"Internal Conversion Data Function","code":""},{"path":"https://cmmid.github.io/paramix/reference/to_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal Conversion of Data to Function — to_function","text":"","code":"to_function(x, interp_opts)"},{"path":"https://cmmid.github.io/paramix/reference/to_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal Conversion of Data to Function — to_function","text":"x function single argument version x xy.coords() (per approxfun() splinefun() inputs) interp_opts x function, ignored. Otherwise, interpolating function arguments.","code":""},{"path":"https://cmmid.github.io/paramix/reference/to_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal Conversion of Data to Function — to_function","text":"function","code":""}]
